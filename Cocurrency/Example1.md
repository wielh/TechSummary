# 高併發範例一: 搶購

## 情境

短時間內開放搶購商品A，商品A數量為10萬、每個10元，每人限購一次，購買數量為1~5個。

## 基本流程

+ 確認用戶訊息，登入取得 token/session

+ 驗證訂單資訊，執行付款並記錄

## 架構

+ 假設已有微服務 micro-transection 負責執行驗證訂單資訊，付款並記錄。

+ 考慮新增一個微服務 micro-activity 之類的微服務，有以下功能:

    + 設定活動相關參數: 活動日期，貨品數量，預定名額數

    + 驗證活動搶購驗證活動相關條件(比如剩餘數量時)

## 高併發解決方案範例

+ micro-activity: 只選前20萬筆候選訂單，限制接收數量

+ redis: 加上緩存，緩存內容:

    + 活動資訊

    + 用戶名-狀態(處裡中、驗證訂單資料、訂單生成失敗、購物成功等)

        + 假設用戶名 int64，狀態為 short，那麼20萬個用戶數據為 2MB 左右

        + 如果在緩存上找得到用戶名，則表示已參加過，則可以直接返回

    + 訂單計數器，當訂單數大約有20萬筆實關閉活動。

+ micro-activity :驗證完畢後考慮送進 message queue 或程式語言提供的線程安全陣列，並先返回。後續部分進行異步處理。

+ micro-transection :

    + 考慮新增方法: 從 message queue 進行 Batch fetch 訂單資料，然後進行資料驗證(多線程)

    + 負責執行驗證訂單資訊，訂單資訊插入資料庫使用 BatchInsert 與 PreparedStatement，可以的話盡量改造成支持批量交易

+ 付款

    + 方法一. 進行批量交易

        + 儲值系統在本地，可以考慮用此方式

        + 因為購買數量最多為5個，所以一次可以取2萬筆訂單，然後批量扣款與更改訂單狀態。

        + 每次批量處理訂單數量可為(剩餘商品/5)進行處理

        + 記得更新商品剩餘數量到DB與redis

    + 方法二. 每次進行單筆交易

        + 如果調用是第三方支付且不支持批量交易，只能用此方法

        + 後臺起一些執行緒，使用 redis 用來儲存訂單號，以及倉儲計數器作為分佈式鎖。

        + 假設訂單號為 int64，20萬筆會占用 1.6MB
        
        + 轉帳時，必須向分佈式鎖(倉儲計數器)取得數量，如果交易失敗則返還。

        + 這些執行緒會取用訂單號執行單筆交易(轉帳，訂單改為OK)，如果任一步驟失敗，則其他步驟全部取消。

        + 跑過一遍訂單後，如果還是有剩庫存，可以考慮進行重試

    


