# 其他特性

## make/new 區別

+ make :用於創建和初始化特定類型的集合類型：slice（切片）、map（映射）和 channel（通道），返回的是這些類型的具體值（而不是指針）。

    ``````go
    make(type, size, capacity)
    ``````
    + type：要創建的集合類型（slice、map 或 channel）。
    + size：初始大小（僅適用於切片和通道）。
    + capacity：切片的容量（可選，若不指定則與 size 相同）。

+ new: 用於分配內存空間，但不初始化（僅設為零值）。返回的是分配類型的指針。
    ``````go
    new(type)
    ``````
    + 用於分配內存空間，但不初始化（僅設為零值）。
    + 返回的是分配類型的指針。
    + 通常用於分配結構體或基本類型的內存空間。

## slice/array 區別

+ introduction

    |  特點  | Array（數組） | Slice（切片） |
    | ------- | -------- | -------- |
    | 長度 | 固定，無法改變 | 動態，可增長或縮小 |
    | 定義方式 | var a [5]int |	var s []int 或 make([]int, size, cap) |
    | 內存分配 | 靜態分配，直接包含數據	| 動態分配，指向底層數組 |
    | 性能	| 比切片稍快，因為沒有額外的元數據	| 性能略低，因為有指針和元數據的管理 |
    | 拷貝行為	| 值拷貝，會創建一份完整的副本	| 引用拷貝，共享底層數據 |

+ 常見誤區
    + 切片不是數組的指針：切片是基於數組的引用，但包含指針、長度和容量元數據。
    + 切片超出容量會重新分配內存：這是動態數據結構的特性。

## map 
+ key 數值類型: 必須是可比較的，比如 int, string, *T
+ map使用的注意点
    + key的唯一性
    + key的不可變性：作為key的類型必須是可比較的，這通常意味著它們應該是不可變的。例如，在Go語言中，切片、映射和函數類型因為包含可變狀態，所以不能直接作為map的key。
    + 初始化和nil map：在Go語言中，宣告一個map變數不會自動初始化它。未初始化的map變數的零值是nil，對nil map進行讀寫操作會引發panic。因此，在使用map之前，應該使用make函數進行初始化。
    + 遍歷順序：如果你需要按照特定的順序處理map中的元素，你應該先將key提取到一個切片中，對切片進行排序，然後按照排序後的順序遍歷切片，並從map中取出對應的值。這樣，你就可以按照特定的順序處理map中的元素了。
    + 并发安全性：默认情况下，map并不是并发安全的。
+ 可以用 map[T]interface{} 模擬 set