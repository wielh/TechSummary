# Redis 介紹

## 基本特性

+ 内存存储：Redis 将数据存储在内存中，因此具有快速读写操作的优势。对于频繁访问和需要快速响应的应用程序来说，Redis 是一个理想的选择。

+ 持久化 : Redis 所有数据保存在内存当中，对数据的更新将以异步方式保存到磁盘上。

+ 單線程 : Redis 是单线程模型。

+ 主从复制 : Redis 提供了主从复制（Replication）功能，可以创建多个 Redis 实例之间的主从关系，实现数据的备份和故障恢复，提高系统的可用性和可靠性。

+ ACID :

    +  原子性（Atomicity）
    Redis 提供了多种原子操作，例如对单个键的操作（如 INCR、DECR、LPUSH 等）。此外，Redis 的事务（Transaction）通过 MULTI、EXEC、DISCARD 和 WATCH 命令实现，可以确保一组命令在事务内的原子性。然而，Redis 的事务并不支持回滚（ROLLBACK）。

    + 一致性（Consistency）
    在单实例的 Redis 中，通过使用 WATCH 命令，能够实现基本的一致性控制。WATCH 会监控一个或多个键，如果在执行事务期间这些键发生变化，事务将不会执行，从而避免并发修改带来的不一致性。 但需要注意的是，Redis 的一致性取决于应用程序的设计和使用场景，在分布式环境中，Redis 并不能完全保证强一致性。

    + 隔离性（Isolation）
    Redis 提供的事务具有一定的隔离性，即在事务执行期间，其他客户端无法看到事务内部的中间状态。然而，Redis 的事务并不支持传统数据库中的隔离级别（如读未提交、读已提交、可重复读、序列化）。因此，Redis 的隔离性主要通过单线程模型和乐观锁（WATCH）实现，但并不能达到完全的隔离。

    + 持久性（Durability）
    Redis 提供两种持久化方式来保证数据的持久性(預設:無)：
        + RDB（Redis Database File）：定期将数据快照保存到磁盘。适用于不需要实时持久化的场景。
        + AOF（Append-Only File）：记录每个写操作，并将这些操作追加到文件中。可以配置为每秒、每写操作或从不同步（性能和持久性的权衡）。


## 使用場景

+ 緩存:　缓存数据库查询结果與計算結果

+ 实现分布式锁: 利用 Redis 的原子操作和过期时间特性，实现分布式系统中的锁机制，保证操作的原子性和一致性。

+ 存储会话数据: 将用户会话数据(session)存储在 Redis 中，实现分布式系统中的会话共享和状态管理，提高系统的可伸缩性和性能。

+ 实时数据处理：处理实时事件流数据，如实时投票、即时聊天、实时推荐等场景。

+ 地理位置服务：使用 Redis 的地理位置数据结构（如地理哈希和地理半径查询）存储和查询地理位置信息，支持附近用户查找等功能。

## 刪除內存策略

+ 定時+隨機刪除

+ 惰性刪除

+ 內存淘汰策略: 

    只有在 Redis 的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。

    + noeviction:默认策略。内存达到限制时，不再进行任何删除操作，直接拒绝写入操作并返回错误。适用于那些希望确保数据不被删除的场景。

    + allkeys-lru:从所有键中使用 LRU（Least Recently Used，最近最少使用）算法选择键进行删除。适用于缓存场景，自动删除最近最少使用的键。

    + allkeys-random: 从所有键中随机选择键进行删除。适用于希望随机淘汰数据的场景，不依赖于使用模式。

    + volatile-lru:从设置了过期时间的键中使用 LRU 算法选择键进行删除。适用于缓存场景，只有那些设置了过期时间的键会被删除。

    + volatile-random:从设置了过期时间的键中随机选择键进行删除。适用于希望随机淘汰数据的场景，但只限于那些设置了过期时间的键。

    + volatile-ttl:从设置了过期时间的键中选择剩余时间最短的键进行删除。适用于希望优先删除那些即将过期的键的场景。

## 更新內存策略

+ 設置過期時間

+ 定時更新: 由應用程序調用定時任務

+ 主動刷新: DB更新時順便更新緩存

## 需注意的點

+ 緩存雪崩: 大量緩存資料同時失效

+ 緩存穿透: 大量請求查詢在DB不存在的值，導致緩存失效

+ 緩存擊穿: 一些熱點key的值被刪除了